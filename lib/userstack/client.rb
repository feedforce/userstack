# frozen_string_literal: true

require 'cgi'
require 'json'
require 'net/https'

module Userstack
  # A class which wraps calls to Userstack API
  class Client
    # @param access_key [String] Userstack Access key
    # @raise [ArgumentError] when `access_key` is invalid
    # @see https://userstack.com/documentation
    def initialize(access_key, use_ssl: true)
      raise ArgumentError, 'Invalid Access key' if access_key.empty?

      @access_key = access_key.freeze
      @use_ssl = use_ssl
      freeze
    end

    # @return [String] Returns the Access key
    attr_reader :access_key, :use_ssl

    # Parse an useragent using Userstack
    #
    # @param useragent [String] an useragent
    # @return [Hash] a Hash generated by parsing the JSON returned
    #   from the API call, just `{}` on parsing failure
    def parse(useragent)
      response = request(useragent)
      parse_as_json(response.body)
    end

    USERSTACK_API_DOMAIN = 'api.userstack.com'
    private_constant :USERSTACK_API_DOMAIN

    USER_AGENT = 'Userstack gem/%s' % VERSION
    private_constant :USER_AGENT

    private

    def request(useragent)
      uri = request_uri(useragent)
      Net::HTTP.start(uri.host, uri.port, use_ssl: uri.scheme == 'https') do |http|
        http.get(uri.to_s, 'User-Agent' => USER_AGENT)
      end
    end

    def request_uri(useragent)
      scheme = use_ssl ? 'https' : 'http'
      fqdn = URI("#{scheme}://#{USERSTACK_API_DOMAIN}/")
      fqdn.dup.tap do |uri|
        uri.path = '/detect'
        uri.query = {
          access_key: access_key,
          ua: CGI.escape(useragent)
        }.map { |k, v| "#{k}=#{v}" }.join('&')
      end
    end

    def parse_as_json(json_text)
      json_text ||= '{}'
      JSON.parse(json_text)
    rescue JSON::ParserError
      {}
    end
  end
end
