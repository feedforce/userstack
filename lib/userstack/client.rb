# frozen_string_literal: true

require 'json'
require 'net/https'

module Userstack
  # A class which wraps calls to Userstack API
  class Client
    USER_AGENT = 'Userstack gem/%s' % VERSION

    # @param access_key [String] Userstack Access key
    # @param use_ssl [Boolean] Use ssl or not
    # @param legacy [Boolean] Legacy response
    # @raise [ArgumentError] when `access_key` is invalid
    # @see https://userstack.com/documentation
    def initialize(access_key, options = {})
      defaults = { :use_ssl => true, :legacy => false }
      raise ArgumentError, 'Invalid Access key' if access_key.nil? || access_key.empty?

      @access_key = access_key.freeze
      @use_ssl = options.fetch(:use_ssl, defaults[:use_ssl])
      @legacy = options.fetch(:legacy, defaults[:legacy])
      freeze
    end

    # Parse an useragent using Userstack
    #
    # @param useragent [String] an useragent
    # @return [Hash] a Hash generated by parsing the JSON returned
    #   from the API call, just `{}` on parsing failure
    # @raise [ArgumentError] when `useragent` is invalid
    def parse(useragent)
      raise ArgumentError, 'Invalid useragent' if useragent.nil? || useragent.empty?

      response = request(useragent)
      parse_as_json(response.body)
    end

    private

    attr_reader :access_key, :use_ssl, :legacy

    def request(useragent)
      uri = UriBuilder.execute(access_key, useragent, use_ssl, legacy)
      http = Net::HTTP.new(uri.host, uri.port)
      if uri.scheme == 'https'
        http.use_ssl = true
        http.verify_mode = OpenSSL::SSL::VERIFY_PEER
      end
      http.get(uri.to_s, 'User-Agent' => USER_AGENT)
    end

    def parse_as_json(json_text)
      json_text ||= '{}'
      JSON.parse(json_text)
    rescue JSON::ParserError
      {}
    end
  end
end
